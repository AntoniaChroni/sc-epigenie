---
title: "Create a gene activity matrix for sc-ATAC-Seq Analysis in 10X Genomics data"
author: "Antonia Chroni for SJCRH DNB_BINF_Core"
papersize: a4
fontsize: 11pt
links-as-notes: true
output:
  html_document:
    toc: TRUE
    toc_float: TRUE
    df_print: paged
    code_folding: hide
    toc_depth: 2
    highlight: tango
    number_sections: TRUE
  pdf_document:
    toc: TRUE
    highlight: tango
    number_sections: TRUE
    latex_engine: lualatex
    keep_tex: FALSE
    fig_caption: yes
    fig_crop: no
    fig_height: 2
    fig_width: 3
    toc_depth: 2
always_allow_html: TRUE
urlcolor: blue
linkcolor: black
citecolor: blue
geometry: margin=1in
header-includes: 
  - \usepackage{titling}
  - \usepackage{fancyhdr}
  - \usepackage{graphicx}
  - \usepackage{float}
params:
  resolution: '.'
  assay: '.'
  min.cutoff_value: '.'
  compute_gene_activities_manual: '.'
  root_dir: './'
  PROJECT_NAME: '.'
  PI_NAME: '.'
  TASK_ID: '.'
  PROJECT_LEAD_NAME: '.'
  DEPARTMENT: '.'
  LEAD_ANALYSTS: '.'
  GROUP_LEAD: '.'
  CONTACT_EMAIL: '.'
  PIPELINE: '.'
  START_DATE: '.'
  COMPLETION_DATE: '.'
---

```{r logo-file, echo=FALSE}
attach(params)
# Insert logo on the top of the html report 
logo_file <- file.path(root_dir, "figures", "img", "DNB-BINF-Core-logo.png")
htmltools::img(src = knitr::image_uri(logo_file), alt = "logo", style = "position:absolute; top:0; left:0; padding:0px; height:120px;")
detach(params)
```

\addtolength{\headheight}{2.0cm} 
\fancypagestyle{plain}{} 
\thispagestyle{fancy}
\fancyhead[L]{\includegraphics[height=120px]{`r logo_file`}}
\renewcommand{\headrulewidth}{0pt}

<style type="text/css">
:root {--DNB_BINF_Core_color: #00427B;}

h1.title {margin-top: 130px;
          margin-bottom: 25px;
          font-size: 36px;}

.nobullet li {list-style-type: none;}

.reporthead {font-size: 20px;}

body { /* Normal */
  font-size: 16px;
  font-style: Arial, Helvetica, sans-serif;}

h1 {color: var(--DNB_BINF_Core_color);
    font-size: 28px;
    margin-top: 50px;}

h2 {color: var(--DNB_BINF_Core_color);
    font-size: 20px;}

.list-group-item.active, .list-group-item.active:focus, .list-group-item.active:hover {
  background-color: var(--DNB_BINF_Core_color);}
</style>

<a href="https://wiki.stjude.org/display/CAB">

</a>

\pagebreak

<div class="reporthead"><br/>
**PI: `r params$PI_NAME`**  
**Project: `r params$PROJECT_NAME`**  
Task: `r params$TASK_ID`  
Project Lead(s): `r params$PROJECT_LEAD_NAME`  
Department: `r params$DEPARTMENT`  

<br />  

DNB Bioinformatics Core Analysis Team: 
<br />  

>**Lead Analyst(s): `r params$LEAD_ANALYSTS`**  
>Group Lead: `r params$GROUP_LEAD`  
<br />
>**Contact E-mail:** `r params$CONTACT_EMAIL`  
>**DNB Bioinformatics Core Pipeline:** `r params$PIPELINE`  

Date started: `r params$START_DATE`  
Date completed:  `r params$COMPLETION_DATE`  
Report generated: `r format(Sys.time(), '%H:%M:%S %Z %m/%d/%Y')` \

Reviewed by: _____________________   Date: ____________ \
</div>
\pagebreak
  
# Information about this notebook

For more information, please see the [Create a gene activity matrix](https://stuartlab.org/signac/articles/mouse_brain_vignette#create-a-gene-activity-matrix) vignette.

# Set up
```{r load-library, echo=TRUE}
attach(params)
suppressPackageStartupMessages({
  library(future)
  library(tidyverse)
  library(Seurat)
  library(Signac)
  library(knitr)
  library(GenomicRanges)
  library(GenomeInfoDb)
  library(Matrix)
  library(DT)

  # Evaluate Seurat R expressions asynchronously when possible using future package
  options(future.globals.maxSize = future_globals_value, future.rng.onMisuse = "ignore") 
  plan(multisession, workers = parallelly::availableCores())
}) 
```

# Directories and paths to file Inputs/Outputs

```{r set-dir-and-file-names, echo=TRUE}
analysis_dir <- file.path(root_dir, "analyses", "cluster-cell-calling") 
data_dir <- file.path(root_dir, "analyses", "cluster-cell-calling", "results", glue::glue("01_cluster_cell_calling_{resolution}"))
module_results_dir <- file.path(analysis_dir, "results")
module_plots_dir <- file.path(analysis_dir, "plots")

# Input files
data_file <- file.path(data_dir, "seurat_obj_clusters_all.rds")

# Create results_dir
results_dir <- file.path(module_results_dir, "02_create_gene_activity_matrix")
if (!dir.exists(results_dir)) {
  dir.create(results_dir)}

# Create plots directory
#plots_dir <- file.path(module_plots_dir, "02_create_gene_activity_matrix") 
#if (!dir.exists(plots_dir)) {
#  dir.create(plots_dir)}
```


```{r echo=FALSE, warning=FALSE}
opts_chunk$set(fig.align='center',
               external=TRUE,
               echo=FALSE,
               warning=FALSE,
               fig.pos='H')
a4width <- 8.3
a4height <- 11.7
```

# Read seurat object

First, we will use the seurat object as generated from the pipeline in the `r data_dir_module` module. 

```{r read-object, echo=TRUE}
seurat_obj <- readRDS(data_file)
DefaultAssay(seurat_obj) <- assay
```

# Create a gene activity matrix

In single-cell ATAC-seq (scATAC-seq), we measure chromatin accessibility at regulatory regions across the genome. However, the raw output is a peak-by-cell matrix, which is sparse and not directly interpretable at the gene level. To enable integration with other data types (like scRNA-seq) and improve interpretability, we summarize chromatin accessibility at the level of genes. This is done by:

   - Associating accessible peaks near or within gene loci to the corresponding genes
   - Summing accessibility signals across those peaks
   - Producing a gene-by-cell activity matrix analogous to a gene expression matrix

This gene activity matrix can then be:

   - Used for clustering, label transfer, or trajectory inference
   - Integrated with scRNA-seq data (multi-omics workflows)
   - Visualized to infer regulatory activity

Here, the user can select to implement the following strategies to generate the Gene Activity Matrix.

### Automated Generation of Gene Activity Matrix

The `GeneActivity()` function is automated and convenient for quick analyses:

- Uses a default promoter window (typically ±2 kb around the TSS) for peak-to-gene mapping
- Relies on a fixed reference genome and gene annotation, which may not match the custom annotations used (e.g., from Ensembl or GENCODE).

### Manual Generation of Gene Activity Matrix

We created a manual approach that allows for: 

- Fine-grained control over how peaks are mapped to genes (e.g., including full gene bodies, adjusting overlap criteria)
- Explicit harmonization between the peak matrix and genome annotations, ensuring all data layers are correctly aligned
- Transparent, reproducible logic, which is especially important in publication-quality workflows or when using custom or multi-species references

By manually building the gene activity matrix, we ensure that every step is fully auditable and tailored to our dataset, which would not be possible with the default behavior of `GeneActivity()`.


```{r compute-gene-activities-manual, echo=TRUE}
# Indicates whether or not to use miQC
if (compute_gene_activities_manual == "YES"){
  print("We will compute the gene activities matrix manually.")
  
  ###----------- let's debug ---------------------------------
  # Step 1: Use peaks from the count matrix (ensures matching order)
  # Here we ensure exact alignment with the Seurat object. GeneActivity() internally recomputes peak mappings, which might not exactly match your filtered or preprocessed peak set.
  peak_names <- rownames(seurat_obj[["peaks"]])
  peaks_gr <- StringToGRanges(peak_names, sep = c("-", "-"))

  # Step 2: Get the gene annotations
  anno <- Annotation(seurat_obj)

  # Step 3: Harmonize chromosomes (seqlevels) between peaks and annotations
  # Manual quality control and harmonization.
  # We’re manually aligning seqlevels (chromosome naming conventions) between peaks and annotations, which GeneActivity() doesn’t expose directly.
  # This avoids mismatches that can silently reduce our peak-to-gene overlap set.
  common_seqlevels <- intersect(seqlevels(peaks_gr), seqlevels(anno))
  peaks_gr <- keepSeqlevels(peaks_gr, common_seqlevels, pruning.mode = "coarse")
  anno <- keepSeqlevels(anno, common_seqlevels, pruning.mode = "coarse")

  # Step 4: Subset peak count matrix to peaks in filtered peaks_gr
  # Convert back GRanges to strings
  #filtered_peak_names <- paste0(seqnames(peaks_gr), "-", start(peaks_gr), "-", end(peaks_gr))

  # Subset counts matrix to matching rows
  #counts <- GetAssayData(seurat_obj, assay = "peaks", layer = "counts")
  #counts <- counts[filtered_peak_names, ]

  # Confirm match
  #stopifnot(nrow(counts) == length(peaks_gr))

  # Step 5: Find overlaps
  # You're explicitly overlapping our own GRanges of peaks with our own gene annotations.
  # GeneActivity() uses a fixed logic — usually overlapping peaks with promoters only, defined as ±2kb around the TSS by default.
  # User might be using full gene bodies or custom promoter definitions.
  overlaps <- findOverlaps(peaks_gr, anno)

    # Subset peaks_gr regions to regions which had a hit in the findOverlaps results
  peak_region_hits <- peaks_gr[queryHits(overlaps)]

  # Subset anno regions to regions which had a peaks region overlapping them in the findOverlaps results
  anno_region_hits <- anno[subjectHits(overlaps)]

  # Create a data frame which records the peak regions with overlapping hits,
  # the anno region which it overlaps,
  # the corresponding gene names from the anno regions,
  # and the gene ids from the anno regions
  peaks_genes_df <- data.frame("peak_regions" = paste0(seqnames(peak_region_hits), "-", start(peak_region_hits), "-", end(peak_region_hits)),
                               "anno_regions" = paste0(seqnames(anno_region_hits), "-", start(anno_region_hits), "-", end(anno_region_hits)),
                               "gene_name" = anno_region_hits$gene_name,
                               "gene_id" = anno_region_hits$gene_id)

  # Since some regions may not have a gene name annotation, use gene ids for those regions
  # Make a column which uses gene_id if gene_name is missing
  peaks_genes_df$gene <- ifelse(peaks_genes_df$gene_name != "", peaks_genes_df$gene_name, peaks_genes_df$gene_id)
  
  # If a peak region matches the same gene multiple times, only want to count it towards gene activity once
  # Otherwise we will be falsely inflating the gene activity contributed from the duplicated peak region
  # So deduplicate the peaks_genes_df based on the peak region column and gene column

  # Note this can happens for things like genes with multiple transcript isoforms for example
  # So then the peak region would be the same and even the anno region might be the same
  # And the gene name and id is the same, but the transcript ID is where it differs, which cause multiple hits for the same peak region with the same gene name/id
  peaks_genes_df_dedup <- distinct(peaks_genes_df, peak_regions, gene, .keep_all= TRUE)

  # Generate a matrix from the peak counts matrix which includes only those peak regions identified to overlap anno regions
  peaks_genes_matrix <- seurat_obj@assays$peaks@counts[peaks_genes_df_dedup$peak_regions,]

  # Set rownames for this matrix to the gene annotations
  # Note that matrices can have duplicated rownames
  # So this matrix can and likely will have multiple rows for the same gene 
  # This happens when multiple different peak regions overlap the same gene region from the anno regions
  rownames(peaks_genes_matrix) <- peaks_genes_df_dedup$gene

  # Collapse matrix to have one row per gene by summing all rows with the same gene name
  peaks_genes_matrix_sum <- DelayedArray::rowsum(peaks_genes_matrix, rownames(peaks_genes_matrix))

  # Add the gene activity matrix to the Seurat object
  seurat_obj[["RNA"]] <- CreateAssayObject(counts = peaks_genes_matrix_sum)
  ###--------------------------------------------
  
  } else {
    print("We will compute the gene activities matrix by using the GeneActivity() function.")
    
    # compute gene.activities
    # GeneActivity() assumes:
    # - Default promoter size window
    # - Fixed reference genome and gene annotation
    # If the user is using custom annotations (e.g., from Ensembl or GENCODE) or need to ensure full reproducibility in a publication-quality workflow, the manual approach is safer.
   gene.activities <- GeneActivity(seurat_obj)

   # Optionally: add gene activity matrix as a new assay to your Seurat object
   seurat_obj[["RNA"]] <- CreateAssayObject(counts = gene.activities)
}
```

Now we can visualize the activities of canonical marker genes to help interpret our ATAC-seq clusters. Note that the activities will be much noisier than scRNA-seq measurements. This is because they represent measurements from sparse chromatin data, and because they assume a general correspondence between gene body/promoter accessibility and gene expression which may not always be the case. Nonetheless, we can begin to discern cell populations based on these gene activity profiles. 

```{r normalize-matrix, echo=TRUE}
# Normalize the gene activity data (optional but common)
seurat_obj <- NormalizeData(seurat_obj, 
                            assay = "RNA",
                            normalization.method = 'LogNormalize',
                            scale.factor = median(seurat_obj$nCount_RNA))

seurat_obj <- FindVariableFeatures(seurat_obj, assay = "RNA")

# View features
# VariableFeatures(seurat_obj[["RNA"]])[1:10]
```

```{r feature-plot, echo=TRUE, eval=FALSE}
DefaultAssay(seurat_obj) <- 'RNA'

print(FeaturePlot(
  object = seurat_obj,
  
  # Add genes specific to your cohort
  features = c('MS4A1', 'CD3D', 'LEF1', 'NKG7', 'TREM1', 'LYZ'),
  pt.size = 0.1,
  max.cutoff = min.cutoff_value,
  ncol = 3))
```

Now we have:

  - A new assay "RNA" in the Seurat object that contains a gene-by-cell matrix of inferred regulatory activity.
  - A foundation for label transfer, dimensionality reduction, or integration with scRNA-seq.
  
```{r gene-activities-interactive-table, echo=TRUE, eval=FALSE}
# Get expression data (e.g., normalized counts)
rna_matrix <- as.data.frame(as.matrix(seurat_obj[["RNA"]]@data))

# Interactive Table
DT::datatable(rna_matrix, 
          options = list(pageLength = 5, 
                         autoWidth = TRUE, 
                         server = TRUE), 
          filter = "top")
```

# Save output files

```{r save-obj, echo=TRUE}
saveRDS(seurat_obj, file = paste0(results_dir, "/", "seurat_obj_gene_activity_matrix.rds"))
```

```{r echo=FALSE}
detach(params)
```

\pagebreak

# Session Info

```{r echo=FALSE}
sessionInfo()
```

